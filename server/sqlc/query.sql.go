// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package sqlc

import (
	"context"
	"net/netip"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const auth = `-- name: Auth :one
INSERT INTO author (ip)
VALUES ($1)
ON CONFLICT (ip)
DO UPDATE SET 
    ip = $1
RETURNING id, ip
`

func (q *Queries) Auth(ctx context.Context, ip netip.Addr) (Author, error) {
	row := q.db.QueryRow(ctx, auth, ip)
	var i Author
	err := row.Scan(&i.ID, &i.Ip)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comment (author, post, content)
VALUES ($1, $2, $3)
RETURNING id, post, author, reply, content, created_at
`

type CreateCommentParams struct {
	Author  uuid.UUID `json:"author"`
	Post    int32     `json:"post"`
	Content string    `json:"content"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Author, arg.Post, arg.Content)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Post,
		&i.Author,
		&i.Reply,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createCommentWithReply = `-- name: CreateCommentWithReply :one
INSERT INTO comment (author, post, content, reply)
VALUES ($1, $2, $3, $4)
RETURNING id, post, author, reply, content, created_at
`

type CreateCommentWithReplyParams struct {
	Author  uuid.UUID   `json:"author"`
	Post    int32       `json:"post"`
	Content string      `json:"content"`
	Reply   pgtype.Int4 `json:"reply"`
}

func (q *Queries) CreateCommentWithReply(
	ctx context.Context, arg CreateCommentWithReplyParams,
) (Comment, error) {
	row := q.db.QueryRow(ctx, createCommentWithReply,
		arg.Author,
		arg.Post,
		arg.Content,
		arg.Reply,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Post,
		&i.Author,
		&i.Reply,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO post (author, content)
VALUES ($1, $2)
RETURNING id, author, created_at, content
`

type CreatePostParams struct {
	Author  uuid.UUID `json:"author"`
	Content string    `json:"content"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost, arg.Author, arg.Content)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.CreatedAt,
		&i.Content,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comment
WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteComment, id)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM post
WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePost, id)
	return err
}

const getComment = `-- name: GetComment :one
SELECT 
    comment.id,
    comment.author,
    comment.content,
    reply_comment.id as "reply_comment_id",
    reply_comment.author as "reply_comment_author",
    comment.created_at,
    coalesce(likes.count, 0) as "likes_count",
    CASE WHEN mine_like.id IS NOT NULL THEN true ELSE false END as "is_liked"
FROM comment
LEFT JOIN (
    SELECT count(comment_like.comment) as "count", comment_like.comment as "comment_id" FROM comment_like
    GROUP BY comment_like.comment
) as likes
ON likes.comment_id = comment.id
LEFT JOIN (
    SELECT comment_like.comment as "id" FROM comment_like 
    WHERE comment_like.author = $2
) as mine_like 
ON mine_like.id = comment.id
LEFT JOIN comment as reply_comment 
ON reply_comment.id = comment.reply
WHERE comment.id = $1
`

type GetCommentParams struct {
	ID     int32     `json:"id"`
	Author uuid.UUID `json:"author"`
}

type GetCommentRow struct {
	ID                 int32              `json:"id"`
	Author             uuid.UUID          `json:"author"`
	Content            string             `json:"content"`
	ReplyCommentID     pgtype.Int4        `json:"replyCommentId"`
	ReplyCommentAuthor pgtype.UUID        `json:"replyCommentAuthor"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	LikesCount         int64              `json:"likesCount"`
	IsLiked            bool               `json:"isLiked"`
}

func (q *Queries) GetComment(ctx context.Context, arg GetCommentParams) (GetCommentRow, error) {
	row := q.db.QueryRow(ctx, getComment, arg.ID, arg.Author)
	var i GetCommentRow
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.Content,
		&i.ReplyCommentID,
		&i.ReplyCommentAuthor,
		&i.CreatedAt,
		&i.LikesCount,
		&i.IsLiked,
	)
	return i, err
}

const getCommentAuthor = `-- name: GetCommentAuthor :one
SELECT author from comment 
WHERE id = $1
`

func (q *Queries) GetCommentAuthor(ctx context.Context, id int32) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getCommentAuthor, id)
	var author uuid.UUID
	err := row.Scan(&author)
	return author, err
}

const getComments = `-- name: GetComments :many
SELECT 
    comment.id,
    comment.author,
    comment.content,
    reply_comment.id as "reply_comment_id",
    reply_comment.author as "reply_comment_author",
    comment.created_at,
    coalesce(likes.count, 0) as "likes_count",
    CASE WHEN mine_like.id IS NOT NULL THEN true ELSE false END as "is_liked"
FROM comment
LEFT JOIN (
    SELECT count(comment_like.comment) as "count", comment_like.comment as "comment_id" FROM comment_like
    GROUP BY comment_like.comment
) as likes
ON likes.comment_id = comment.id
LEFT JOIN (
    SELECT comment_like.comment as "id" FROM comment_like 
    WHERE comment_like.author = $2
) as mine_like 
ON mine_like.id = comment.id
LEFT JOIN comment as reply_comment 
ON reply_comment.id = comment.reply
WHERE comment.post = $1 AND CASE WHEN $5::text != '' THEN comment.content ILIKE concat('%', $5::text, '%') ELSE true END
ORDER BY 
      CASE WHEN $6::bool THEN comment.created_at END ASC,
      CASE WHEN $7::bool THEN comment.created_at END DESC,
      CASE WHEN $8::bool THEN likes.count END ASC
LIMIT $3 OFFSET $4
`

type GetCommentsParams struct {
	Post     int32     `json:"post"`
	Author   uuid.UUID `json:"author"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
	Search   string    `json:"search"`
	DateAsc  bool      `json:"dateAsc"`
	DateDesc bool      `json:"dateDesc"`
	TopAsc   bool      `json:"topAsc"`
}

type GetCommentsRow struct {
	ID                 int32              `json:"id"`
	Author             uuid.UUID          `json:"author"`
	Content            string             `json:"content"`
	ReplyCommentID     pgtype.Int4        `json:"replyCommentId"`
	ReplyCommentAuthor pgtype.UUID        `json:"replyCommentAuthor"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	LikesCount         int64              `json:"likesCount"`
	IsLiked            bool               `json:"isLiked"`
}

func (q *Queries) GetComments(
	ctx context.Context, arg GetCommentsParams,
) ([]GetCommentsRow, error) {
	rows, err := q.db.Query(ctx, getComments,
		arg.Post,
		arg.Author,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.DateAsc,
		arg.DateDesc,
		arg.TopAsc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsRow
	for rows.Next() {
		var i GetCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Content,
			&i.ReplyCommentID,
			&i.ReplyCommentAuthor,
			&i.CreatedAt,
			&i.LikesCount,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostAuthor = `-- name: GetPostAuthor :one
SELECT author from post
WHERE id = $1
`

func (q *Queries) GetPostAuthor(ctx context.Context, id int32) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getPostAuthor, id)
	var author uuid.UUID
	err := row.Scan(&author)
	return author, err
}

const getPosts = `-- name: GetPosts :many
SELECT 
    post.id, 
    post.author, 
    post.created_at, 
    post.content, 
    coalesce(likes.count, 0) as "likes_count",
    coalesce(comments.count, 0) as "comments_count",
    CASE WHEN mine_like.id IS NOT NULL THEN true ELSE false END as "is_liked"
FROM post  
LEFT JOIN (
    SELECT count(post_like.post) as "count", post_like.post as "post_id" FROM post_like
    GROUP BY post_like.post
) as likes
ON likes.post_id = post.id
LEFT JOIN (
    SELECT count(comment.id) as "count", comment.post as "post_id" FROM comment 
    GROUP BY comment.post
) as comments
ON comments.post_id = post.id
LEFT JOIN (
    SELECT post_like.post as "id" FROM post_like 
    WHERE post_like.author = $1
) as mine_like 
ON mine_like.id = post.id
WHERE CASE WHEN $4::text != '' THEN post.content ILIKE concat('%', $4::text, '%') ELSE true END
ORDER BY 
      CASE WHEN $5::bool THEN post.created_at END ASC,
      CASE WHEN $6::bool THEN post.created_at END DESC,
      CASE WHEN $7::bool THEN likes.count END ASC
LIMIT $2 OFFSET $3
`

type GetPostsParams struct {
	Author   uuid.UUID `json:"author"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
	Search   string    `json:"search"`
	DateAsc  bool      `json:"dateAsc"`
	DateDesc bool      `json:"dateDesc"`
	TopAsc   bool      `json:"topAsc"`
}

type GetPostsRow struct {
	ID            int32              `json:"id"`
	Author        uuid.UUID          `json:"author"`
	CreatedAt     pgtype.Timestamptz `json:"createdAt"`
	Content       string             `json:"content"`
	LikesCount    int64              `json:"likesCount"`
	CommentsCount int64              `json:"commentsCount"`
	IsLiked       bool               `json:"isLiked"`
}

func (q *Queries) GetPosts(ctx context.Context, arg GetPostsParams) ([]GetPostsRow, error) {
	rows, err := q.db.Query(ctx, getPosts,
		arg.Author,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.DateAsc,
		arg.DateDesc,
		arg.TopAsc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsRow
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.CreatedAt,
			&i.Content,
			&i.LikesCount,
			&i.CommentsCount,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const likeComment = `-- name: LikeComment :one
INSERT INTO comment_like (author, comment)
VALUES ($1, $2)
RETURNING author, comment
`

type LikeCommentParams struct {
	Author  uuid.UUID `json:"author"`
	Comment int32     `json:"comment"`
}

func (q *Queries) LikeComment(ctx context.Context, arg LikeCommentParams) (CommentLike, error) {
	row := q.db.QueryRow(ctx, likeComment, arg.Author, arg.Comment)
	var i CommentLike
	err := row.Scan(&i.Author, &i.Comment)
	return i, err
}

const likePost = `-- name: LikePost :one
INSERT INTO post_like (author, post)
VALUES ($1, $2)
RETURNING author, post
`

type LikePostParams struct {
	Author uuid.UUID `json:"author"`
	Post   int32     `json:"post"`
}

func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (PostLike, error) {
	row := q.db.QueryRow(ctx, likePost, arg.Author, arg.Post)
	var i PostLike
	err := row.Scan(&i.Author, &i.Post)
	return i, err
}

const unlikeComment = `-- name: UnlikeComment :exec
DELETE FROM comment_like
WHERE comment = $1 AND author = $2
`

type UnlikeCommentParams struct {
	Comment int32     `json:"comment"`
	Author  uuid.UUID `json:"author"`
}

func (q *Queries) UnlikeComment(ctx context.Context, arg UnlikeCommentParams) error {
	_, err := q.db.Exec(ctx, unlikeComment, arg.Comment, arg.Author)
	return err
}

const unlikePost = `-- name: UnlikePost :exec
DELETE FROM post_like
WHERE post = $1 AND author = $2
`

type UnlikePostParams struct {
	Post   int32     `json:"post"`
	Author uuid.UUID `json:"author"`
}

func (q *Queries) UnlikePost(ctx context.Context, arg UnlikePostParams) error {
	_, err := q.db.Exec(ctx, unlikePost, arg.Post, arg.Author)
	return err
}
